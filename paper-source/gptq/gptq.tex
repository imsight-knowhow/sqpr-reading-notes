
\documentclass{article} % For LaTeX2e
\usepackage{iclr2023_conference,times}

% Optional math commands from https://github.com/goodfeli/dlbook_notation.
\input{math_commands.tex}

\usepackage[hidelinks]{hyperref}
\usepackage{url}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{letltxmacro}
\usepackage{subcaption}
\usepackage{graphicx}

\usepackage{multirow}
\usepackage{caption}
\usepackage{array, booktabs}       % professional-quality tables
\usepackage{wrapfig}

\renewcommand{\paragraph}[1]{ \noindent \textbf{#1}}
\linespread{0.98}
\setlength{\abovecaptionskip}{1pt}
\setlength{\belowcaptionskip}{1pt}
%% around equations
\setlength{\abovedisplayskip}{1pt}
\setlength{\belowdisplayskip}{1pt}
\setlength\abovedisplayshortskip{1pt}
\setlength\belowdisplayshortskip{1pt}

\title{GPTQ:  Accurate Post-Training Quantization \\ for Generative Pre-trained Transformers}

% Authors must not appear in the submitted version. They should be hidden
% as long as the \iclrfinalcopy macro remains commented out below.
% Non-anonymous submissions will be rejected without review.

\author{
    \hspace{-5pt} Elias Frantar\thanks{Corresponding author: \texttt{elias.frantar@ist.ac.at}} \\
    IST Austria \\
    \And
    Saleh Ashkboos  \\
    ETH Zurich \\
    \And
    Torsten Hoefler  \\
    ETH Zurich \\
    \And
    Dan Alistarh \\
    IST Austria \& NeuralMagic \\
}

% The \author macro works with any number of authors. There are two commands
% used to separate the names and addresses of multiple authors: \And and \AND.
%
% Using \And between authors leaves it to \LaTeX{} to determine where to break
% the lines. Using \AND forces a linebreak at that point. So, if \LaTeX{}
% puts 3 of 4 authors names on the first line, and the last on the second
% line, try using \AND instead of \And before the third author name.

\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\iclrfinalcopy % Uncomment for camera-ready version, but NOT for submission.
\begin{document}

\maketitle

\begin{abstract}
Generative Pre-trained Transformer models, known as GPT or OPT, set themselves apart through breakthrough performance across complex language modelling tasks, but also by their extremely high computational and storage costs. Specifically, due to their massive size, even inference for large, highly-accurate GPT models may require multiple performant GPUs, which limits the usability of such models. While there is emerging work on relieving this pressure via model compression, the applicability and performance of existing compression techniques is limited by the scale and complexity of GPT models. In this paper, we address this challenge, and propose GPTQ, a new one-shot weight quantization method based on approximate second-order information, that is both highly-accurate and highly-efficient. Specifically, GPTQ can quantize GPT models with 175 billion parameters in approximately four GPU hours, reducing the bitwidth down to 3 or 4 bits per weight, with negligible accuracy degradation relative to the uncompressed baseline. Our method more than doubles the compression gains relative to previously-proposed one-shot quantization methods, preserving accuracy, allowing us for the first time to execute an 175 billion-parameter model inside a single GPU for generative inference. 
Moreover, we also show that our method can still provide reasonable accuracy in the \emph{extreme quantization} regime, 
in which weights are quantized to 2-bit or even \emph{ternary} quantization levels.
We show experimentally that these improvements can be leveraged for end-to-end inference speedups over FP16, of around 3.25x when using high-end GPUs (NVIDIA A100) and 4.5x when using more cost-effective ones (NVIDIA A6000). The implementation is available at \url{https://github.com/IST-DASLab/gptq}.
\end{abstract}

\section{Introduction}
\vspace{-0.5em}

Pre-trained generative models from the Transformer~\citep{vaswani2017attention} family, commonly known as GPT or OPT~\citep{radford2019language, brown2020language, zhang2022opt}, have shown breakthrough performance for complex language modelling tasks, leading to massive academic and practical interest. One major obstacle to their usability is computational and storage cost, which ranks among the highest for known models. For instance, the best-performing model variants, e.g. GPT3-175B, have in the order of 175 billion parameters and require tens-to-hundreds of GPU years to train~\citep{zhang2022opt}. Even the simpler task of inferencing over a pre-trained model, which is our focus in this paper, is highly challenging: for instance, the parameters of GPT3-175B occupy 326GB (counting in multiples of 1024) of memory when stored in a compact float16 format. This exceeds the capacity of even the highest-end single GPUs, and thus inference must be performed using more complex and expensive setups, such as multi-GPU deployments. 

Although a standard approach to eliminating these overheads is \emph{model compression}, e.g.~\citep{hoefler2021sparsity, gholami2021survey}, surprisingly little is known about compressing such models for inference. 
One reason is that more complex methods for low-bitwidth quantization or model pruning usually require \emph{model retraining}, which is extremely expensive for billion-parameter models. 
Alternatively, \emph{post-training} methods~\citep{nagel2020up, wang2020towards, hubara2020improving, nahshan2021loss}, which compress the model in one shot, without retraining, would be very appealing. 
Unfortunately, the more accurate variants of such methods~\citep{li2021brecq,hubara2021accurate,frantar2022obc} are complex and challenging to scale to billions of parameters~\citep{yao2022zeroquant}. 
To date, only basic variants of round-to-nearest quantization~\citep{yao2022zeroquant, dettmers2022llm} have been applied at the scale of GPT-175B; while this works well for low compression targets, e.g., 8-bit weights, they fail to preserve accuracy at higher rates. It therefore remains open whether one-shot \emph{post-training quantization} to higher compression rates is generally-feasible.

\begin{figure}[h]
    \centering
    \begin{subfigure}{0.45\linewidth}
        \centering
        \includegraphics[width=\linewidth]{opt4-abs.pdf}
    \end{subfigure}
    \begin{subfigure}{0.45\linewidth}
        \centering
        \includegraphics[width=\linewidth]{bloom3-abs.pdf}
    \end{subfigure}
    \caption{Quantizing OPT models to 4 and BLOOM models to 3 bit precision, comparing GPTQ with the FP16 baseline and round-to-nearest (RTN)~\citep{yao2022zeroquant, dettmers2022llm}.}
    \label{fig:intro-comparison}
\end{figure}

\paragraph{Contribution.} In this paper, we present a new post-training quantization method, called GPTQ,\footnote{This merges the name of the OPT model family with the abbreviation for post-training quantization (PTQ).} which is efficient enough to execute on models with hundreds of billions of parameters in at most a few hours, 
and precise enough to compress such models to 3 or 4 bits per parameter without significant loss of accuracy. 
For illustration, GPTQ can quantize the largest publicly-available models, OPT-175B and BLOOM-176B, in approximately four GPU hours, with minimal increase in perplexity, known to be a very stringent accuracy metric. 

Further, we show that our model can also provide robust results in the \emph{extreme quantization} regime, in which models are quantized to 2 bits per component, or even \emph{ternary values}.  
On the practical side, we develop an execution harness which allows us to execute the resulting compressed models efficiently for generative tasks. 
Specifically, we are able to run the compressed OPT-175B model for the first time on a single NVIDIA A100 GPU, or using only two more cost-effective NVIDIA A6000 GPUs. We also implement bespoke GPU kernels which are able to leverage compression for faster memory loading, 
resulting in speedups of $\approx 3.25 \times$ when using A100 GPUs, and $4.5\times$ when using A6000 GPUs.

To our knowledge, we are the first to show that extremely accurate language models with hundreds of billions of parameters can be quantized to 3-4 bits/component: prior \emph{post-training methods} only remain accurate at 8 bits~\citep{yao2022zeroquant, dettmers2022llm}, while prior \emph{training-based} techniques have only tackled  models that are smaller by one to two orders of magnitude~\citep{wu2022extreme}. This high degree of compression may appear natural, as these networks are overparametrized; yet, as we discuss in our detailed analysis of results, compression induces non-trivial tradeoffs between the accuracy of the language modeling (perplexity), bit-width, and the size of the original model. 

We hope that our work will stimulate further research in this area, and can be a further step towards making these models available to a wider audience. 
In terms of limitations, our method currently does not provide speedups for the actual multiplications, due to the lack of hardware support for mixed-precision operands (e.g. FP16 x INT4) on mainstream architectures. Moreover, our current results do not include activation quantization, as they are not a significant bottleneck in our target scenarios; however, this can be supported using orthogonal techniques~\citep{yao2022zeroquant}.

\section{Related Work}

Quantization methods fall broadly into two categories: quantization during training, and post-training methods. The former quantize models during typically extensive retraining and/or finetuning, using some approximate differentiation mechanism for the rounding operation \citep{gholami2021survey, nagel2021white}. By contrast, post-training (``one-shot'') methods quantize a pretrained model using modest resources, typically a few thousand data samples and a few hours of computation. Post-training approaches are particularly interesting for massive models, for which full model training or even finetuning can be expensive. 
We focus on this scenario here. 

\paragraph{Post-training Quantization.} 
Most post-training methods have focused on vision models.  
Usually, accurate methods operate by quantizing either individual layers, or small blocks of consecutive layers. (See Section \ref{sec:layerwise-quantization} for more details.) 
The AdaRound method~\citep{nagel2020up} computes a data-dependent rounding by annealing a penalty term, which encourages weights to move towards grid points corresponding to quantization levels. BitSplit~\citep{wang2020towards} constructs quantized values bit-by-bit using a squared error objective on the residual error, while AdaQuant \citep{hubara2021accurate} performs direct optimization based on straight-through estimates.
BRECQ \citep{li2021brecq} introduces Fisher information into the objective, and optimizes layers within a single residual block jointly. 
Finally, Optimal Brain Quantization (OBQ) \citep{frantar2022obc} generalizes the classic Optimal Brain Surgeon (OBS) second-order weight pruning framework~\citep{hassibi1993optimal, singh2020woodfisher, frantar2021m} to apply to quantization. 
OBQ quantizes weights one-by-one, in order of quantization error, always adjusting the remaining weights. 
While these approaches can produce good results for models up to $\approx 100$ million parameters in a few GPU hours, scaling them to networks orders of magnitude larger is challenging.
 
\paragraph{Large-model Quantization.} With the recent open-source releases of language models like BLOOM~\citep{laurencconbigscience} or OPT-175B~\citep{zhang2022opt}, researchers have started to develop affordable methods for compressing such giant networks for inference. 
While all existing works---ZeroQuant~\citep{yao2022zeroquant}, LLM.int8()~\citep{dettmers2022llm}, and nuQmm~\citep{park2022nuqmm}--- carefully select quantization granularity, e.g., vector-wise, they ultimately just round weights to the nearest (RTN) quantization level, in order to maintain acceptable runtimes for very large models. 
ZeroQuant further proposes layer-wise knowledge distillation, similar to AdaQuant, but the largest model it can apply this approach to has only 1.3 billion parameters. At this scale, ZeroQuant already takes $\approx 3$ hours of compute; GPTQ quantizes models 100$\times$ larger in $\approx 4$ hours.
LLM.int8() observes that \emph{activation outliers} in a few feature dimensions break the quantization of larger models, and proposes to fix this problem by keeping those dimensions in higher precision. Lastly, nuQmm develops efficient GPU kernels for a specific binary-coding based quantization scheme.

Relative to this line of work, we show that a significantly more complex and accurate quantizer can be implemented efficiently at large model scale. 
Specifically, GPTQ more than doubles the amount of compression  relative to these prior techniques, at similar accuracy.  

\vspace{-0.7em}
\section{Background}
\vspace{-0.5em}
\label{sec:layerwise-quantization}

\paragraph{Layer-Wise Quantization.} At a high level, our method follows the structure of state-of-the-art post-training quantization methods \citep{nagel2020up, wang2020towards, hubara2021accurate, frantar2022obc}, by performing quantization  layer-by-layer, solving a corresponding reconstruction problem for each layer.
Concretely, let $\mathbf{W_\ell}$ be the weights corresponding to a linear layer $\ell$ and let $\mathbf{X}_\ell$ denote the layer input corresponding to a small set of $m$ data points running through the network. 
Then, the objective is to find a matrix of quantized weights $\mathbf{\widehat{W}}$ which minimizes the squared error, relative to the full precision layer output. Formally, this can be restated as

\vspace{-10pt}
\begin{equation}
    \label{eq:layerwise-quantization}
    \text{argmin}_{\mathbf{\widehat{W}}} \, ||\mathbf{W} \mathbf{X} - \mathbf{\widehat{W}} \mathbf{X}||_2^2.
\end{equation}

Further, similar to \citep{nagel2020up, li2021brecq, frantar2022obc}, we assume that the quantization grid for $\mathbf{\widehat{W}}$ is fixed before the process, 
and that individual weights can move freely as in \citep{hubara2021accurate, frantar2022obc}.

\paragraph{Optimal Brain Quantization.} Our approach builds on the recently-proposed Optimal Brain Quanization (OBQ) method~\citep{frantar2022obc} for solving the layer-wise quantization problem defined above, 
to which we perform a series of major modifications, which allow it to scale to large language models, providing more than \emph{three orders of magnitude} computational speedup. 
To aid understanding, we first briefly summarize the original OBQ method.

The OBQ method starts from the observation that Equation (\ref{eq:layerwise-quantization}) can be written as the sum of the squared errors, over each row of $\mathbf{W}$. 
Then, OBQ handles each row $\mathbf{w}$ independently, quantizing one weight at a time while always updating all not-yet-quantized weights, in order to compensate for the error incurred by quantizing a single weight. 
Since the corresponding objective is a quadratic, whose Hessian is $\mathbf{H}_F = 2\mathbf{X}_F\mathbf{X}_F^\top$, where $F$ denotes the set of remaining full-precision weights, the greedy-optimal weight to quantize next, which we denote by $w_q$, and the corresponding optimal update of all weights in $F$, denoted by $\boldsymbol{\delta}_F$, are given by the following formulas, where $\text{quant}(w)$ rounds $w$ to the nearest value on the quantization grid:

\vspace{-10pt}
\begin{equation}
    \label{eq:obs-quant}
    w_q = \text{argmin}_{w_q} \, \frac{(\text{quant}(w_q) - w_q)^2}{[\mathbf{H}_F^{-1}]_{qq}}, \quad \boldsymbol{\delta}_F = - \frac{w_q - \text{quant}(w_q)}{[\mathbf{H}_F^{-1}]_{qq}} \cdot (\mathbf{H}_F^{-1})_{:, q}.
\end{equation}

OBQ quantizes weights iteratively using these two equations, until all the weights of $\mathbf{w}$  are quantized.
This is done efficiently, avoiding expensive full recomputations of $\mathbf{H}^{-1}$, by removing the $q$th row and column of $\mathbf{H}$, which is necessary after quantizing $w_q$, directly in the inverse via one step of Gaussian elimination. Namely, the updated inverse is given by the formula

\vspace{-10pt}
\begin{equation}
    \label{eq:inv-update}
    \mathbf{H}_{-q}^{-1} = \Big(\mathbf{H}^{-1} - \frac{1}{[\mathbf{H}^{-1}]_{qq}} \mathbf{H}^{-1}_{:, q} \mathbf{H}^{-1}_{q, :} \Big)_{-p}.
\end{equation}

This method comes with a vectorized implementation, handling multiple rows of $\mathbf{W}$ in parallel. 
Eventually, the algorithm can achieve reasonable runtimes on medium-sized models: for instance, it can fully quantize the  ResNet-50 model (25M parameters) in $\approx 1$ hour on a single GPU, which is roughly in line with other post-training methods achieving state-of-the-art accuracy~\citep{frantar2022obc}. 
However, the fact that OBQ's runtime for a $d_\text{row} \times d_\text{col}$ matrix $\mathbf{W}$ has \emph{cubic} input dependency $O(d_\text{row} \cdot d_\text{col}^3)$ means that applying it to models with billions of parameters is extremely expensive.

\vspace{-5pt}
\section{The GPTQ Algorithm}
\vspace{-5pt}
\label{sec:gptq}

\paragraph{Step 1: Arbitrary Order Insight.} As explained in the previous section, OBQ quantizes weights in greedy order, i.e. it always picks the weight which currently incurs the least additional quantization error. Interestingly, we find that, while this quite natural strategy does indeed seem to perform very well, its improvement over quantizing the weights in arbitrary order is generally small, in particular on large, heavily-parametrized layers. 
Most likely, this is because the slightly lower number of quantized weights with large individual error is balanced out by those weights being quantized towards the end of the process, when only few other unquantized weights that can be adjusted for compensation remain. As we will now discuss, this insight that \emph{any fixed order may perform well}, especially on large models, has interesting ramifications.

\begin{wrapfigure}{r}{0.49\textwidth}
  \vspace{-20pt}
  \begin{center}
    \includegraphics[width=\linewidth]{gptq-new-2.pdf}
  \end{center}
      \caption{ GPTQ quantization procedure. Blocks of consecutive \emph{columns} (bolded) are quantized at a given step, using the inverse Hessian information stored in the Cholesky decomposition, and the remaining weights (blue) are updated at the end of the step. The quantization procedure is applied recursively inside each block: the white middle column is currently being quantized.}
    \vspace{-15pt}
\label{fig:illustration}
\end{wrapfigure}

The original OBQ method quantizes rows of $\mathbf{W}$ independently, in a specific order defined by the corresponding errors. 
By contrast, we will aim to quantize the weights of \emph{all rows in the same order}, and will show that this typically yields results with a final squared error that is similar to the original solutions. As a consequence, the set of unquantized weights $F$ and similarly $\mathbf{H}_F^{-1}$ is always the same for all rows (see Figure~\ref{fig:illustration} for an illustration).
In more detail, the latter is due to the fact that $\mathbf{H}_F$ depends only on the layer inputs $\mathbf{X}_F$, which are the same for all rows, and not on any weights. Therefore, we have to perform the update of $\mathbf{H}_F^{-1}$ given by Equation~(\ref{eq:inv-update}) only $d_\text{col}$ times, once per column, rather than $d_\text{row} \cdot d_\text{col}$ times, once per weight. This reduces the overall runtime from $O(d_\text{row} \cdot d_\text{col}^3)$ to $O(\text{max} \, \{d_\text{row} \cdot d_\text{col}^2, d_\text{col}^3\})$, i.e., by a factor of $\text{min} \, \{d_\text{row}, d_\text{col}\}$. 
For larger models, this difference consists of several orders of magnitude. 
However, before this algorithm can actually be applied to very large models in practice, two additional major problems need to be addressed. 

\paragraph{Step 2: Lazy Batch-Updates.}
First, a direct implementation of the scheme described previously will not be fast in practice, because the algorithm has a relatively low compute-to-memory-access ratio. For example, Equation~(\ref{eq:inv-update}) needs to update all elements of a potentially huge matrix using just a few FLOPs for each entry. Such operations cannot properly utilize the massive compute capabilities of modern GPUs, and will be bottlenecked by the significantly lower memory bandwidth.

Fortunately, this problem can be resolved by the following observation: The final rounding decisions for column $i$ are only affected by updates performed on this very column, and so updates to later columns are irrelevant at this point in the process. This makes it possible to ``lazily batch'' updates together, thus achieving much better GPU utilization. Concretely, we apply the algorithm to $B = 128$ columns at a time, keeping updates contained to those columns and the corresponding $B \times B$ block of $\mathbf{H}^{-1}$ (see also Figure~\ref{fig:illustration}). Only once a block has been fully processed, we perform global updates of the entire $\mathbf{H}^{-1}$ and $\mathbf{W}$ matrices using the multi-weight versions of Equations~(\ref{eq:obs-quant}) and (\ref{eq:inv-update}) given below, with $Q$ denoting a set of indices, and $\mathbf{H}_{-Q}^{-1}$ denoting the inverse matrix with the corresponding rows and columns removed: 

\vspace{-10pt}
\begin{align}
    \boldsymbol{\delta}_F &= -(\mathbf{w}_Q - \text{quant}(\mathbf{w}_Q))([\mathbf{H}_F^{-1}]_{QQ})^{-1} (\mathbf{H}_F^{-1})_{:, Q}, \\ 
    \mathbf{H}_{-Q}^{-1} &= \Big(\mathbf{H}^{-1} - \mathbf{H}^{-1}_{:, Q} ([\mathbf{H}^{-1}]_{QQ})^{-1} \mathbf{H}^{-1}_{Q, :} \Big)_{-Q}. \label{eq:group-inv-update}
\end{align}

Although this strategy does not reduce the theoretical amount of compute, it effectively addresses the memory-throughput bottleneck. This provides an order of magnitude speedup for very large models in practice, making it a critical component of our algorithm.

\paragraph{Step 3: Cholesky Reformulation.}
The final technical issue we have to address is given by numerical inaccuracies, which can become a major problem at the scale of existing models, especially when combined with the block updates discussed in the previous step.  
Specifically, it can occur that the matrix $\mathbf{H}_F^{-1}$ becomes indefinite, which we notice can cause the algorithm to aggressively update the remaining weights in incorrect directions, resulting in an arbitrarily-bad quantization of the corresponding layer.
In practice, we observed that the probability of this happening increases with model size: concretely, it almost certainly occurs for at least a few layers on models that are larger than a few billion parameters. 
The main issue appears to be the repeated applications of Equation~(\ref{eq:group-inv-update}), which accumulate various numerical errors, especially through the additional matrix inversion.

For smaller models, applying dampening, that is adding a small constant $\lambda$ (we always choose 1\% of the average diagonal value) to the diagonal elements of $\mathbf{H}$ appears to be sufficient to avoid numerical issues. However, larger models require a more robust and general approach.

To address this, we begin by noting that the only information required from $\mathbf{H}_{F_q}^{-1}$, where $F_q$ denotes the set of unquantized weights when quantizing weight $q$, is row $q$, or more precisely, the elements in this row starting with the diagonal. The consequence is that we could precompute all of these rows using a more numerically-stable method without any significant increase in memory consumption. 
Indeed, the row removal via (\ref{eq:inv-update}) for our symmetric $\mathbf{H}^{-1}$ essentially corresponds to taking a Cholesky decomposition, except for the minor difference that the latter divides row $q$ by $([\mathbf{H}^{-1}_{F_q}]_{qq})^{1/2}$. Hence, we can leverage state-of-the-art Cholesky kernels to compute all information we will need from $\mathbf{H}^{-1}$ upfront. In combination with mild dampening, the resulting method is robust enough to execute on huge models without issues. As a bonus, using a well-optimized Cholesky kernel also yields further speedup. We detail all small changes necessary for the Cholesky version of the algorithm next.

\paragraph{The Full Algorithm.}
Finally, we present the full pseudocode for GPTQ in Algorithm \ref{alg:gptq}, including the optimizations discussed above.

\newlength{\commentindent}
\setlength{\commentindent}{.45\textwidth}
\makeatletter
\renewcommand{\algorithmiccomment}[1]{\unskip\hfill\makebox[\commentindent][l]{\textit{//~#1}}\par}
\LetLtxMacro{\oldalgorithmic}{\algorithmic}
\renewcommand{\algorithmic}[1][0]{%
  \oldalgorithmic[#1]%
  \renewcommand{\ALC@com}[1]{%
    \ifnum\pdfstrcmp{##1}{default}=0\else\algorithmiccomment{##1}\fi}%
}
\makeatother

\begin{algorithm}[H]
    \centering
    \caption{Quantize $\mathbf{W}$ given inverse Hessian $\mathbf{H}^{-1} = (2 \mathbf{X} \mathbf{X}^\top + \lambda \mathbf{I})^{-1}$ and blocksize $B$.}
    \small
    \label{alg:gptq}
    \begin{algorithmic}
        \STATE $\mathbf{Q} \gets \mathbf{0}_{d_\text{row} \times d_\text{col}}$ \quad \COMMENT{quantized output}
        \STATE $\mathbf{E} \gets \mathbf{0}_{d_\text{row} \times B}$ \quad \COMMENT{block quantization errors}
        \STATE $\mathbf{H}^{-1} \gets \text{Cholesky}
        (\mathbf{H}^{-1})^\top$ \COMMENT{Hessian inverse information}
        \FOR {$i = 0, B, 2B, \dots$}
            \FOR {$j = i, \dots, i + B - 1$}
                \STATE $\mathbf{Q}_{:, j} \gets \text{quant}(\mathbf{W}_{:, j})$ \quad \COMMENT{quantize column}
                \STATE $\mathbf{E}_{:, j - i} \gets (\mathbf{W}_{:, j} - \mathbf{Q}_{:, j}) \, / \, [\mathbf{H}^{-1}]_{jj}$ \COMMENT{quantization error}
                \STATE $\mathbf{W}_{:, j:(i + B)} \gets \mathbf{W}_{:, j:(i + B)} - \mathbf{E}_{:, j - i} \cdot \mathbf{H}^{-1}_{j, j:(i + B)}$ \COMMENT{update weights in block}
            \ENDFOR
            \STATE $\mathbf{W}_{:, (i + B):} \gets \mathbf{W}_{:, (i + B):} - \mathbf{E} \cdot \mathbf{H}^{-1}_{i:(i + B), (i + B):}$ \COMMENT{update all remaining weights}
        \ENDFOR
    \end{algorithmic}
\end{algorithm}

\section{Experimental Validation}
\label{sec:experiments}

\paragraph{Overview.} We begin our experiments by validating the accuracy of GPTQ relative to other accurate-but-expensive quantizers, on smaller models, for which these methods provide reasonable runtimes.
Next, we examine GPTQ's runtime scaling for very large models. 
Then, we present 3- and 4-bit quantization results for the entire BLOOM and OPT model families, evaluated via perplexity on challenging language generation tasks.
In addition, we show that our
method is also stable for 2-bit quantization when the granularity is reduced to small blocks of consecutive weights.
To complement this perplexity analysis, we also evaluate the resulting quantized models on a series of standard zero-shot tasks.
Finally, we focus on the two largest (and interesting) openly-available models, Bloom-176B and OPT-175B, where we perform a detailed evaluation on several tasks.
For these models, we also present practical improvements, namely reducing the number of GPUs required for inference as well as end-to-end speedups for generative tasks.

\paragraph{Setup.} We implemented GPTQ in PyTorch \citep{paszke2019pytorch} and worked with the HuggingFace integrations of the BLOOM~\citep{laurencconbigscience} and OPT~\citep{zhang2022opt} model families. We quantized all models (including the 175 billion parameter variants) \emph{using a single NVIDIA A100 GPU} with 80GB of memory. 
Our entire GPTQ calibration data consists of 128 random 2048 token segments from the C4 dataset~\citep{C4}, i.e., excerpts from randomly crawled websites, which represents generic text data. 
We emphasize that this means that GPTQ does not see any task-specific data, and our results thus remain actually ``zero-shot''. 
We perform standard uniform per-row asymmetric quantization on the min-max grid, similar to~\cite{dettmers2022llm}. Additional evaluation details can be found in Appendix \ref{app:evaluation}.

To ensure that the entire compression procedure can be performed with significantly less GPU memory than what would be required to run the full precision model, some care must be taken. Specifically, we always load one Transformer block, consisting of 6 layers, at a time into GPU memory and then accumulate the layer-Hessians and perform quantization. Finally, the current block inputs are sent through the fully quantized block again to produce the new inputs for the quantization of the next block. Hence, the quantization process operates not on the layer inputs in the full precision model but on the actual layer inputs in the already partially quantized one. We find that this brings noticeable improvements at negligible extra cost.

\paragraph{Baselines.} Our primary baseline, denoted by RTN, consists of rounding all weights to the nearest quantized value on exactly the same asymmetric per-row grid that is also used for GPTQ, meaning that it corresponds precisely to the state-of-the-art weight quantization of LLM.int8(). This is currently the method of choice in all works on quantization of very large language models~\citep{dettmers2022llm, yao2022zeroquant, park2022nuqmm}: its runtime scales well to networks with many billions of parameters, as it simply performs direct rounding. As we will also discuss further, more accurate methods, such as AdaRound~\citep{nagel2020up} or BRECQ~\citep{li2021brecq}, are currently too slow for models with many billions of parameters, the main focus of this work. Nevertheless, we also show that GPTQ is competitive with such methods for small models, while scaling to huge ones like OPT-175B as well.

\paragraph{Quantizing Small Models.} As a first ablation study, we compare GPTQ's performance relative to state-of-the-art post-training quantization (PTQ) methods, on ResNet18 and ResNet50, which are standard PTQ benchmarks, in the same setup as~\citep{frantar2022obc}. 
As can be seen in Table~\ref{tab:ptq-vision-comp}, GPTQ performs on par at 4-bit, and slightly worse than the most accurate methods at 3-bit. At the same time, it significantly outperforms AdaQuant, the fastest amongst prior PTQ methods. 
Further, we compare against the full greedy OBQ method on two smaller language models: BERT-base \citep{devlin2018bert} and OPT-125M. 
The results are shown in Appendix Table~\ref{tab:obq-comparison}. 
At 4 bits, both methods perform similarly, and for 3 bits, GPTQ surprisingly performs slightly better. 
We suspect that this is because some of the additional heuristics used by OBQ, such as early outlier rounding, might require careful adjustments for optimal performance on non-vision models. 
Overall, GPTQ appears to be competitive with state-of-the-art post-training methods for smaller models, while taking only $< 1$ minute rather than $\approx 1$ hour. 
This enables scaling to much larger models.

\begin{table}[h]
\begin{minipage}[t]{.45\textwidth}
    \centering
    \vspace{0pt}
    \scalebox{0.9}{
        \begin{tabular}{|l|cc|cc|}
            \toprule
            \multirow{2}{*}{Method} & \multicolumn{2}{c|}{RN18 -- 69.76 \%} & \multicolumn{2}{c|}{RN50 -- 76.13\%} \\
            & 4bit & 3bit & 4bit & 3bit \\
            \midrule
            AdaRound & 69.34 & 68.37 & 75.84 & 75.14 \\
            AdaQuant & 68.12 & 59.21 & 74.68 & 64.98 \\
            BRECQ & 69.37 & 68.47 & 75.88 & 75.32 \\
            OBQ  & 69.56 & 68.69 & 75.72 & 75.24 \\
            \midrule
            GPTQ & 69.37 & 67.88 & 75.71 & 74.87 \\
            \bottomrule
        \end{tabular}
    }
    \vspace{5pt}
    \caption{Comparison with state-of-the-art post-training methods for vision models.}
    \label{tab:ptq-vision-comp}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
    \centering
    \vspace{15pt}
    \scalebox{0.9}{
        \begin{tabular}{|l|cccc|}
            \toprule
            OPT & 13B & 30B & 66B & 175B \\
            \midrule
            Runtime & 20.9m & 44.9m & 1.6h & 4.2h \\
            \midrule
            BLOOM & 1.7B & 3B & 7.1B & 176B \\
            \midrule
            Runtime & 2.9m & 5.2m & 10.0m & 3.8h \\
            \bottomrule
        \end{tabular}
    }
    \vspace{5pt}
    \caption{GPTQ runtime for full quantization of the 4 largest OPT and BLOOM models.}
    \label{tab:gptq-runtime}
\end{minipage}
\vspace{-10pt}
\end{table}

\paragraph{Runtime.} Next we measure the full model quantization time (on a single NVIDIA A100 GPU) via GPTQ; the results are shown in Table \ref{tab:gptq-runtime}. As can be seen, GPTQ quantizes 1-3 billion parameter models in a matter of minutes and 175B ones in a few hours. For reference, the straight-through based method ZeroQuant-LKD \citep{yao2022zeroquant} reports a 3 hour runtime (on the same hardware) for a 1.3B model, which would linearly extrapolate to several hundred hours (a few weeks) for 175B models. Adaptive rounding-based methods typically employ a lot more SGD steps and would thus be even more expensive \citep{nagel2020up, li2021brecq}.

\paragraph{Language Generation.} 
We begin our large-scale study by compressing the entire OPT and BLOOM model families to 3- and 4-bit.
We then evaluate those models on several language tasks including WikiText2~\citep{wikitext103} (see Figure \ref{fig:intro-comparison} as well as Tables \ref{tab:opt-wikitext2} and \ref{tab:bloom-wikitext2}), Penn Treebank (PTB)~\citep{PTB}  and C4~\citep{C4} (both in Appendix~\ref{app:generation}).
We focus on these perplexity-based tasks, as they are known to be particularly sensitive to model quantization~\citep{yao2022zeroquant}. 
On OPT models, GPTQ clearly outperforms RTN, by significant margins. 
For example, GPTQ loses only 0.03 perplexity at 4-bit on the 175B model, while RTN drops 2.2 points, performing worse than the $10\times$ smaller full-precision 13B model. 
At 3-bit, RTN collapses completely, while GPTQ can still maintain reasonable perplexity, in particular for larger models. 
BLOOM shows a similar pattern: the gaps between methods are however usually a bit smaller, indicating that this model family might be easier to quantize. 
One interesting trend (see also Figure~\ref{fig:intro-comparison}) is that larger models generally (with the exception of OPT-66B\footnote{Upon closer inspection of the OPT-66B model, it appears that this is correlated with the fact that this trained model has a significant fraction of dead units in the early layers, which may make it harder to compress.}) appear easier to quantize. 
This is good news for practical applications, as these are the cases where compression is also the most necessary.

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|}
        \toprule
        OPT & Bits & 125M & 350M & 1.3B & 2.7B & 6.7B & 13B & 30B & 66B & 175B \\
        \midrule
        full & 16 & 27.65 & 22.00 & 14.63 & 12.47 & 10.86 & 10.13 & 9.56 & 9.34 & 8.34 \\
        \midrule
        RTN & 4 & 37.28 & 25.94 & 48.17 & 16.92 & 12.10 & 11.32 & 10.98 & 110 & 10.54 \\
        GPTQ & 4 & \textbf{31.12} & \textbf{24.24} & \textbf{15.47} & \textbf{12.87} & \textbf{11.39} & \textbf{10.31} & \textbf{9.63} & \textbf{9.55} & \textbf{8.37} \\
        \midrule
        RTN & 3 & 1.3e3 & 64.57 & 1.3e4 & 1.6e4 & 5.8e3 & 3.4e3 & 1.6e3 & 6.1e3 & 7.3e3 \\
        GPTQ & 3 & \textbf{53.85} & \textbf{33.79} & \textbf{20.97} & \textbf{16.88} & \textbf{14.86} & \textbf{11.61} & \textbf{10.27} & \textbf{14.16} & \textbf{8.68} \\
        \bottomrule
    \end{tabular}
    \vspace{5pt}
    \caption{OPT perplexity results on WikiText2.}
    \label{tab:opt-wikitext2}
\end{table}
\vspace{-10pt}
\begin{table}[h!]
    \centering
    \begin{tabular}{|l|c|c|c|c|c|c|c|}
        \toprule
        BLOOM & Bits & 560M & 1.1B & 1.7B & 3B & 7.1B & 176B \\
        \midrule
        full & 16 & 22.42 & 17.69 & 15.39 & 13.48 & 11.37 & 8.11 \\
        \midrule
        RTN & 4 & 25.90 & 22.00 & 16.97 & 14.76 & 12.10 & 8.37 \\
        GPTQ & 4 & \textbf{24.03} & \textbf{19.05} & \textbf{16.48} & \textbf{14.20} & \textbf{11.73} & \textbf{8.21} \\
        \midrule
        RTN & 3 & 57.08 & 50.19 & 63.59 & 39.36 & 17.38 & 571 \\
        GPTQ & 3 & \textbf{32.31} & \textbf{25.08} & \textbf{21.11} & \textbf{17.40} & \textbf{13.47} & \textbf{8.64} \\
        \bottomrule
    \end{tabular}
    \vspace{5pt}
    \caption{BLOOM perplexity results for WikiText2.}
    \label{tab:bloom-wikitext2}
\end{table}

\paragraph{175 Billion Parameter Models.} We now examine BLOOM-176B and OPT-175B, the largest dense openly-available models.
Table~\ref{tab:results-biggest-models} summarizes results across Wikitext-2, PTB, C4.
We observe that, at 4 bits, GPTQ models reach only $\leq 0.25$ lower perplexity than the full-precision versions, with a large gap to RTN results on OPT-175B.
At 3-bit, RTN collapses, while GPTQ is still able to maintain good performance on most tasks, losing only $0.3 - 0.6$ points for more than $5\times$ compression. 
We note that GPTQ's accuracy can be further improved via finer-granularity grouping~\citep{park2022nuqmm}: group-size 1024 ($\approx$ 0.02 extra bits) improves perplexities by about $0.2$ on average and group-size 128 ($\approx$ 0.15 extra bits) by another $0.1$, which is only $0.1 - 0.3$ off from the uncompressed accuracy. We note that grouping interacts very well with GPTQ, as the group parameters can be
determined during the quantization process of each layer, always using the most current updated weights.

 \begin{table}[h]
    \centering
    \scalebox{0.9}{
        \begin{tabular}{|c|c|ccc|c|ccc|c|}
            \toprule
            \multirow{2}{*}{Method} & \multirow{2}{*}{Bits} & \multicolumn{4}{c|}{OPT-175B} & \multicolumn{4}{c|}{BLOOM-176B} \\
            & & Wiki2 & PTB & C4 & LAMB. $\uparrow$  & Wiki2 & PTB & C4 & LAMB. $\uparrow$ \\
            \midrule
            Baseline & 16 & 8.34 & 12.01 & 10.13 & 75.59 & 8.11 & 14.59 & 11.71 & 67.40 \\
            \midrule
            RTN & 4 & 10.54 & 14.22 & 11.61 & 71.34 & 8.37 & 15.00 & 12.04 & 66.70 \\
            GPTQ & 4 & \textbf{8.37} & \textbf{12.26} & \textbf{10.28} &
            \textbf{76.80} &
            \textbf{8.21} & \textbf{14.75} & \textbf{11.81} &
            \textbf{67.71} \\
            \midrule
            RTN & 3 & 7.3e3 & 8.0e3 & 4.6e3 & 0 & 571. & 107. & 598. & 0.17 \\
            GPTQ & 3 & \textbf{8.68} & \textbf{12.68} & \textbf{10.67} & 
            \textbf{76.19} &
            \textbf{8.64} & \textbf{15.57} & \textbf{12.27} &
            \textbf{65.10} \\
            \midrule
            GPTQ & 3/g1024 & 8.45 & 12.48 & 10.47 & 77.39 & 8.35 & 15.01 
 & 11.98 & 67.47 \\
            GPTQ & 3/g128 & 8.45 & 12.37 & 10.36 & 76.42 & 8.26 & 14.89 & 11.85 & 67.86 \\
            \bottomrule
        \end{tabular}
     }
     \vspace{5pt}
     \caption{Results summary for OPT-175B and BLOOM-176B. ``g1024'' and ``g128'' denote results with groupings of size 1024 and 128, respectively.}
     \label{tab:results-biggest-models}
 \end{table}

\paragraph{Practical Speedups.} 
Finally, we study practical applications. 
As an interesting use-case, we focus on the OPT-175B model: quantized to 3 bits, this model takes approximately 63GB of memory, including the embeddings and the output layer, which are kept in full FP16 precision. 
Additionally, storing the complete history of keys and values for all layers, a common optimization for generation tasks, consumes another $\approx 9$GB for the maximum of 2048 tokens. Hence, we can actually fit the entire quantized model into a single 80GB A100 GPU, which can be executed by dynamically dequantizing layers as they are required during inference (the model would not fully fit using 4 bits). 
For reference, standard FP16 execution requires 5x80GB GPUs, and the state-of-the-art 8bit LLM.int8() quantizer~\citep{dettmers2022llm} requires 3 such GPUs. 

Next, we consider language generation, one of the most appealing applications of these models, with the goal of latency reduction.
Unlike LLM.int8(), which reduces memory costs but has the same runtime as the FP16 baseline, we show that our quantized models can achieve significant speedups for this application. 
For language generation, the model processes and outputs one token at-a-time, which for OPT-175B can easily take a few 100s of milliseconds per token. 
Increasing the speed at which the user receives generated results is challenging, as compute is dominated by matrix-vector products.
Unlike matrix-matrix products, these are primarily limited by memory bandwidth. 
We address this problem by developing a quantized-matrix full-precision-vector product kernel which performs a matrix vector product by dynamically dequantizing weights when needed. Most notably, this does \emph{not} require any activation quantization.
While dequantization consumes extra compute, the kernel has to access a lot less memory, leading to significant speedups, as shown in Table~\ref{tab:practical-results}. We note that almost all of the speedup is due to our kernels, as communication costs are negligible in our standard HuggingFace-accelerate-like setting (see Appendix \ref{app:benchmarking-setup} for details).

\begin{table}[h]
    \centering
    \scalebox{0.9}{
        \begin{tabular}{|l|c|c|c|c|}
             \toprule
             GPU & FP16 & 3bit & Speedup & GPU reduction \\
             \midrule
             A6000 -- 48GB & 589ms & 130ms & $4.53\times$ & $8 \rightarrow 2$ \\
             A100 -- 80GB & 230ms & 71ms & $3.24\times$ & $5 \rightarrow 1$ \\
             \bottomrule
        \end{tabular}
    }
    \vspace{5pt}
    \caption{Average per-token latency (batch size 1) when generating sequences of length 128.}
    \label{tab:practical-results}
\end{table}

For example, using our kernels, the 3-bit OPT-175B model obtained via GPTQ running on a single A100 is about $\mathbf{3.25\boldsymbol{\times}}$ faster than the FP16 version (running on 5 GPUs) in terms of average time per token.
More accessible GPUs, such as the NVIDIA A6000, have much lower memory bandwidth, so this strategy is even more effective: executing the 3-bit OPT-175B model on 2x A6000 GPUs reduces latency from 589 milliseconds for FP16 inference (on 8 GPUs) to 130 milliseconds, a $\mathbf{4.5\boldsymbol{\times}}$ latency reduction.

\begin{figure}[h]
        \centering
        \includegraphics[width=0.9\linewidth]{lambada_task.pdf}
    \caption{The accuracy of OPT and BLOOM models post-GPTQ, measured on LAMBADA.}
    \label{fig:lambada_task}
\end{figure}

\paragraph{Zero-Shot Tasks.} While our focus is on language generation, we also evaluate the performance of quantized models on some popular zero-shot tasks, namely LAMBADA~\citep{paperno2016lambada}, ARC (Easy and Challenge)~\citep{boratko2018systematic} and  PIQA~\citep{tata2003piqa}. 
Figure \ref{fig:lambada_task} visualizes model performance on LAMBADA (and see also ``Lamb." results in Table \ref{tab:results-biggest-models}). 
We observe similar behavior as before: the outliers are that 1) quantization appears ``easier'' across the whole spectrum of models at 4-bit, where even RTN performs relatively well, and 2) at 3-bit, RTN breaks down, while GPTQ still provides good accuracy. We provide additional results in Appendix~\ref{app:zero-shot}.

\paragraph{Additional Tricks.} While our experiments so far have focused exclusively on vanilla row-wise quantization, we want to emphasize that GPTQ is \emph{compatible with essentially any choice of quantization grid}. For example, it is easily combined with standard \textit{grouping} \citep{alistarh2016qsgd, park2022nuqmm}, i.e. applying independent quantization to groups of $g$ consecutive weights. As shown in the last rows of Table \ref{tab:results-biggest-models}, this can bring noticeable extra accuracy for the largest models at 3-bit. Further, as visualized in Figure \ref{fig:4bit-grouping}, it significantly reduces the accuracy losses for medium sized models at 4-bit precision.

\begin{table}[h]
\begin{minipage}[t]{.5\textwidth}
    \vspace{-70pt}
    \centering
    \scalebox{0.9}{
        \begin{tabular}{|l|c|ccc|c|}
            \toprule
            Model & FP16 & g128 & g64 & g32 & 3-bit \\
            \midrule
            OPT-175B & 8.34 & 9.58 & 9.18 & 8.94 & 8.68 \\
            BLOOM & 8.11 & 9.55 & 9.17 & 8.83 & 8.64 \\
            \bottomrule
        \end{tabular}
     }
    \vspace{5pt}
    \caption{2-bit GPTQ quantization results with varying group-sizes; perplexity on WikiText2.}
    \label{tab:2bit}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
    \centering
    \includegraphics[width=\linewidth]{groupsizes.pdf}    
    \captionof{figure}{GPTQ at 4-bit with different group-sizes on medium sized OPT models.}
    \label{fig:4bit-grouping}
\end{minipage}
\end{table}

\paragraph{Extreme Quantization.} Lastly, grouping also makes it possible to achieve reasonable performance for extreme quantization, to around 2-bits per component on average. Table~\ref{tab:2bit} shows results on WikiText2 when quantizing the biggest models to 2-bit with varying group-sizes. At $\approx 2.2$ bit (group-size 128; using FP16 scale and 2-bit zero point per group) the perplexity increase is already less than 1.5 points, while dropping to 0.6 - 0.7 at $\approx 2.6$ bit (group-size 32), which is only slightly worse than vanilla 3-bit and might be interesting for practical kernel implementations. Further, if we reduce group size to 8, we can apply \emph{ternary} (-1, 0, +1) quantization, which achieves 9.20 WikiText2 PPL on OPT-175B, a less than 1 point drop. 
While this leads to worse compression on average relative to the 2-bit numbers above, this pattern could be efficiently implemented on custom hardware such as FPGAs. 
In summary, these results are an encouraging first step towards pushing highly-accurate \emph{one-shot} compression of very large language models, even lower than 3 bits per value on average.

\section{Summary and Limitations}

We have presented GPTQ, an approximate second-order method for quantizing truly large language models. 
GPTQ can accurately compress some of the largest publicly-available models down to 3 and 4 bits, which leads to significant usability improvements, and to end-to-end speedups, at low accuracy loss. 
We hope that our method will make these models accessible to more researchers and practitioners. 
At the same time, we emphasize some significant limitations: 
On the technical side, our method obtains speedups from reduced memory movement, and does not lead to computational reductions. 
In addition, our study focuses on generative tasks, and does not consider activation quantization. 
These are natural directions for future work, and we believe this can be achieved with carefully-designed GPU kernels and existing techniques~\citep{yao2022zeroquant, wu2022extreme}.

\section*{Acknowledgments}

Elias Frantar and Dan Alistarh gratefully acknowledge funding from the European Research Council (ERC) under the European Unionâ€™s Horizon 2020 programme (grant agreement No. 805223 ScaleML), as well as experimental support from Eldar Kurtic, and from the IST Austria IT department, in particular Stefano Elefante, Andrei Hornoiu, and Alois Schloegl. 
The work of Saleh Ashkboos and Torsten Hoefler was supported by the PASC DaCeMI project, received EuroHPC-JU funding under grant MAELSTROM, No. 955513. We thank the Swiss National Supercomputing Center (CSCS) for supporting us with compute infrastructure.

\section{Ethics Statement}

Our work introduces a general method for compressing large language models (LLMs) via quantization, with little-to-no accuracy loss in terms of standard accuracy metrics such as perplexity. 
Our method is task-agnostic, as it only uses a tiny amount of randomly-chosen data for calibration. 
We therefore do not foresee any significant ethical implications arising directly from the technical details of our method. 
However, one possible consideration is that our study focused on ``leading accuracy'' metrics that are standard in the literature, such as perplexity, which is essentially standard in the literature~\citep{dettmers2022llm, yao2022zeroquant}. 
We believe a thorough study of the impact of compression upon secondary measures, and in particular bias effects~\citep{bender2021dangers} is warranted, and may be rendered easier through our work.  
At the same time, our work makes inference on extremely large language models more accessible, for better or for worse. 
We believe that, in time, such tools will become much easier to use and deploy, making the need to understand their power and limitations even more stringent. 

\section{Reproducibility Statement} 

In the Supplementary Materials, we provide code to reproduce all experiments in this paper. More specifically, this includes:

\begin{itemize}
    \item Compressing all models from the OPT and BLOOM model families to 2/3/4 bits.
    \item Evaluating perplexity of the quantized models.
    \item Our 3-bit CUDA kernel together with compressed inference benchmarking features.
    \item Code for the ZeroShot experiments.
    \item A README file providing sample commands and information on how to run all scripts.
\end{itemize}

\bibliography{references}
\bibliographystyle{iclr2023_conference}

\newpage

\appendix
\section{Appendix}

\subsection{Additional Comparison with OBQ}
\label{app:obq-comparison}

We now provide an additional comparison between GPTQ and OBQ on BERT-base/SQuAD \cite{rajpurkar2016squad} and OPT-125M/WikiText2, which is one of the largest models to which OBQ can be reasonably applied. 

\begin{table}[h]
\centering
    \begin{tabular}{|l|cc|cc|}
        \toprule
        \multirow{2}{*}{Method} & \multicolumn{2}{c|}{BERT-base} & \multicolumn{2}{c|}{OPT-125M} \\ 
         & \multicolumn{2}{c|}{88.53 F1 $\uparrow$} & \multicolumn{2}{c|}{27.66 PPL $\downarrow$}  \\ 
         & 4bit & 3bit & 4bit & 3bit \\
        \midrule
        
        OBQ & 88.23 & 85.29 & 32.52 & 69.32 \\
        GPTQ & 88.18 & 86.02 & 31.12 & 53.85 \\
        \bottomrule
    \end{tabular}
    \vspace{5pt}
    \caption{Comparison of GPTQ relative to OBQ on BERT-base/SQuAD and OPT-125M/WikiText2.}
    \label{tab:obq-comparison}
\end{table}

\subsection{Experiment Details}

This section provides additional details about our experiment setup, in particular regarding the model evaluation and the setup of our timing experiments.

\subsubsection{Evaluation}
\label{app:evaluation}

For language generation experiments, we calculate the perplexity, in standard fashion like \cite{radford2019language}, as follows: First, the entire validation set is concatenated using two linebreaks as separators and encoded using the default HuggingFace tokenizer of each model. Next, the sequence is split into non-overlapping segments of width 2048, the full context size of our models. These are sent through the model to collect the log-probabilities corresponding to the next token each. Their exponentiated average is the final perplexity we report.

For zero-shot tasks we follow the EleutherAI evaluation harness\footnote{\url{https://github.com/EleutherAI/lm-evaluation-harness}} in terms of data preprocessing and final score calculation. We note that we evaluate all individual samples separately and thus do not apply any padding.

\subsubsection{Timing Experiment Setup}
\label{app:benchmarking-setup}

Our timing experiments are performed following the standard HuggingFace/accelerate\footnote{\url{https://huggingface.co/docs/accelerate/index}} setup also used by the recent work LLM.int8() \citep{dettmers2022llm}. In this setting, the model is split by distributing chunks of consecutive layers across GPUs. Importantly, in this setup the communication costs are minimal, $< 5\%$ of the total runtime even when working with 8 GPUs. This means almost all of the reported speedups are due to our quantized-matrix full-precision vector product kernels. We emphasize that the only difference between the FP16 baseline and our quantized models are the kernels used to perform the underlying matrix-vector products.

This means all overheads due to HuggingFace, attention or non-quantized operations like residuals or LayerNorms are exactly the same. Consequently, our quantized models should benefit from more advanced distribution strategies \citep{zheng2022alpa} or more efficient attention kernels \citep{dao2022flashattention} just as much as our baseline.

In general, our kernels target generative inference in the low batch-size setting (for simplicity, we consider only batchsize 1) where the underlying (close to) matrix-vector products are memory-bound. For non-generative and large-batch applications, operations may be compute- rather than memory-bound and our kernels thus not directly applicable. Instead, one could simply decompress the matrix before performing the corresponding matrix-matrix calculations: this takes $<$ 1.5ms on an A100 and $<$ 3ms on an A6000 compared to 76ms/365ms for the subsequent OPT-175B FC2 layer computation with batchsize $16 \times 1024$ tokens. Hence, for such applications our methods significantly reduce the required number of GPUs at very little computational overhead. This is similar to recent work \citep{dettmers2022llm}, but we achieve a $2.5\times$ higher compression rate.

\newpage

\subsection{Additional Language Generation Results}
\label{app:generation}

Tables \ref{tab:opt-ptb}, \ref{tab:bloom-ptb}, \ref{tab:opt-c4} and \ref{tab:bloom-c4} show additional results for language generation tasks.

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|}
        \toprule
        OPT & Bits & 125M & 350M & 1.3B & 2.7B & 6.7B & 13B & 30B & 66B & 175B \\
        \midrule
        full & 16 & 38.99 & 31.08 & 20.29 & 17.97 & 15.77 & 14.52 & 14.04 & 13.36 & 12.01 \\
        \midrule
        RTN & 4 & 53.89 & 36.79 & 57.30 & 31.05 & 18.84 & 16.51 & 15.40 & 225.66 & 14.22 \\
        GPTQ & 4 & \textbf{45.17} & \textbf{34.52} & \textbf{21.85} & \textbf{19.14} & \textbf{16.56} & \textbf{14.94} & \textbf{14.26} & \textbf{13.81} & \textbf{12.26} \\
        \midrule
        RTN & 3 & 1.4e3 & 88.04 & 1.3e4 & 1.4e4 & 5.7e3 & 2.8e3 & 1.2e3 & 5.0e3 & 8.0e3 \\
        GPTQ & 3 & \textbf{73.19} & \textbf{47.08} & \textbf{32.10} & \textbf{24.81} & \textbf{21.88} & \textbf{16.68} & \textbf{15.36} & \textbf{28.12} & \textbf{12.86} \\
        \bottomrule
    \end{tabular}
    \vspace{5pt}
    \caption{OPT perplexity results on PTB.}
    \label{tab:opt-ptb}
\end{table}

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|c|c|c|c|c|c|c|}
        \toprule
        BLOOM & Bits & 560M & 1.1B & 1.7B & 3B & 7.1B & 176B \\
        \midrule
        full & 16 & 43.69 & 57.96 & 30.00 & 25.34 & 20.83 & 14.59 \\
        \midrule
        RTN & 4 & 51.10 & 66.85 & 33.58 & 27.68 & 22.42 & 15.00 \\
        GPTQ & 4 & \textbf{46.97} & \textbf{62.47} & \textbf{31.84} & \textbf{26.49} & \textbf{21.67} & \textbf{14.75} \\
        \midrule
        RTN & 3 & 126. & 185. & 106. & 66.78 & 35.04 & 107. \\
        GPTQ & 3 & \textbf{70.35} & \textbf{87.04} & \textbf{46.11} & \textbf{34.02} & \textbf{26.14} & \textbf{15.57} \\
        \bottomrule
    \end{tabular}
    \vspace{5pt}
    \caption{BLOOM perplexity results for PTB.}
    \label{tab:bloom-ptb}
\end{table}

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|}
        \toprule
        OPT & Bits & 125M & 350M & 1.3B & 2.7B & 6.7B & 13B & 30B & 66B & 175B \\
        \midrule
        full & 16 & 26.56 & 22.59 & 16.07 & 14.34 & 12.71 & 12.06 & 11.44 & 10.99 & 10.13 \\
        \midrule
        RTN & 4 & 33.91 & 26.21 & 24.51 & 18.43 & 14.36 & 13.36 & 13.46 & 309. & 11.61 \\
        GPTQ & 4 & \textbf{29.22} & \textbf{24.63} & \textbf{16.97} & \textbf{15.00} & \textbf{13.18} & \textbf{12.26} & \textbf{11.57} & \textbf{11.23} & \textbf{10.28} \\
        \midrule
        RTN & 3 & 834 & 55.49 & 5.2e3 & 1.1e4 & 5.3e3 & 3.1e3 & 1.4e3 & 3.5e3 & 4.6e3 \\
        GPTQ & 3 & \textbf{42.41} & \textbf{31.33} & \textbf{21.63} & \textbf{18.17} & \textbf{17.14} & \textbf{13.34} & \textbf{12.23} & \textbf{14.59} & \textbf{10.67} \\
        \bottomrule
    \end{tabular}
    \vspace{5pt}
    \caption{OPT perplexity results on C4. We note that the calibration data used by GPTQ is sampled from the C4 training set, this task is thus not fully zero-shot.}
    \label{tab:opt-c4}
\end{table}

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|c|c|c|c|c|c|c|}
        \toprule
        BLOOM & Bits & 560M & 1.1B & 1.7B & 3B & 7.1B & 176B \\
        \midrule
        full & 16 & 26.60 & 22.05 & 19.49 & 17.49 & 15.20 & 11.71 \\
        \midrule
        RTN & 4 & 29.89 & 24.44 & 21.26 & 18.76 & 16.06 & 12.04 \\
        GPTQ & 4 & \textbf{28.00} & \textbf{23.25} & \textbf{20.55} & \textbf{18.10} & \textbf{15.60} & \textbf{11.81} \\
        \midrule
        RTN & 3 & 67.49 & 60.71 & 113. & 80.49 & 22.59 & 598. \\
        GPTQ & 3 & \textbf{35.78} & \textbf{28.83} & \textbf{25.34} & \textbf{21.25} & \textbf{17.67} & \textbf{12.27} \\
        \bottomrule
    \end{tabular}
    \vspace{5pt}
    \caption{BLOOM perplexity results for C4. We note that the calibration data used by GPTQ is sampled from the C4 training set, this task is thus not fully zero-shot.}
    \label{tab:bloom-c4}
\end{table}

\newpage

\subsection{Additional ZeroShot Results}
\label{app:zero-shot}

This section contains additional results for zero-shot tasks.


\begin{table}[h!]
    \centering
    \begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|}
        \toprule
        OPT & Bits & 125M & 350M & 1.3B & 2.7B & 6.7B & 13B & 30B & 66B & 175B \\
        \midrule
        full & 16 & 39.16 & 46.67 & 58.80 & 64.82 & 68.72 & 70.23 & 72.39 & 74.93 & 75.59 \\
        \midrule
        RTN & 4 & 18.34 & 40.62 & 36.31 & 59.27 & 64.66 & 67.38 & 70.48 & 13.08 & 71.34 \\
        GPTQ & 4 & \textbf{34.74} & \textbf{48.38} & \textbf{56.45} & \textbf{62.97} & \textbf{66.37} & \textbf{69.12} & \textbf{72.40} & \textbf{74.50} & \textbf{76.80} \\
        \midrule
        RTN & 3 & 0.10 & 27.36 & 0.00 & 0.00 & 0.00 & 0.06 & 1.46 & 2.00 & 0.00 \\
        GPTQ & 3 & \textbf{13.93} & \textbf{32.31} & \textbf{37.26} & \textbf{52.26} & \textbf{54.98} & \textbf{64.18} & \textbf{69.69} & \textbf{57.02} & \textbf{76.19} \\
        \bottomrule
    \end{tabular}
    \vspace{5pt}
    \caption{OPT accuracy on LAMBADA.}
    \label{tab:opt-lambada}
\end{table}

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|c|c|c|c|c|c|c|}
        \toprule
        BLOOM & Bits & 560M & 1.1B & 1.7B & 3B & 7.1B & 176B \\
        \midrule
        full & 16 & 34.06 & 42.85 & 46.71 & 52.12 & 57.79 & 67.40 \\
        \midrule
        RTN & 4 & 26.00 & 39.06 & 41.92 & 45.84 & 50.48 & 66.70 \\
        GPTQ & 4 & \textbf{31.75} & \textbf{39.80} & \textbf{46.28} & \textbf{51.41} & \textbf{54.65} & \textbf{67.71} \\
        \midrule
        RTN & 3 & 9.10 & 15.95 & 15.02 & 24.55 & 29.90 & 0.17 \\
        GPTQ & 3 & \textbf{21.31} & \textbf{28.70} & \textbf{33.65} & \textbf{43.12} & \textbf{47.41} & \textbf{65.10} \\
        \bottomrule
    \end{tabular}
    \vspace{5pt}
    \caption{BLOOM accuracy on LAMBADA.}
    \label{tab:bloom-lambada}
\end{table}

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|}
        \toprule
        OPT & Bits & 125M & 350M & 1.3B & 2.7B & 6.7B & 13B & 30B & 66B & 175B \\
        \midrule
        full & 16 & 62.02 & 64.74 & 72.36 & 74.81 & 76.39 & 76.88 & 78.18 & 79.76 & 81.07 \\
        \midrule
        RTN & 4 & \textbf{61.43} & 63.44 & 67.63 & 73.72 & \textbf{76.44} & 76.01 & 77.26 & 60.07 & 78.23 \\
        GPTQ & 4 & 61.26 & \textbf{63.71} & \textbf{70.73} & \textbf{73.99} & 76.28 & \textbf{76.61} & \textbf{79.00} & \textbf{79.33} & \textbf{81.00} \\
        \midrule
        RTN & 3 & 56.09 & 60.61 & 52.77 & 51.90 & 50.49 & 52.99 & 56.37 & 50.87 & 51.25 \\
        GPTQ & 3 & \textbf{59.25} & \textbf{61.32} & \textbf{68.34} & \textbf{71.38} & \textbf{73.29} & \textbf{75.24} & \textbf{77.58} & \textbf{71.27} & \textbf{80.03} \\
        \bottomrule
    \end{tabular}
    \vspace{5pt}
    \caption{OPT accuracy on PIQA.}
    \label{tab:opt-piqa}
\end{table}

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|c|c|c|c|c|c|c|}
        \toprule
        BLOOM & Bits & 560M & 1.1B & 1.7B & 3B & 7.1B & 176B \\
        \midrule
        full & 16 & 65.07 & 67.14 & 69.97 & 70.51 & 73.72 & 79.16 \\
        \midrule
        RTN & 4 & 63.11 & 65.29 & 67.74 & \textbf{69.86} & 72.69 & \textbf{79.00} \\
        GPTQ & 4 & \textbf{64.31} & \textbf{66.05} & \textbf{68.77} & 69.42 & \textbf{72.96} & \textbf{79.00} \\
        \midrule
        RTN & 3 & 58.60 & 60.80 & 60.88 & 66.28 & 69.70 & 53.32 \\
        GPTQ & 3 & \textbf{61.62} & \textbf{62.62} & \textbf{65.18} & \textbf{68.34} & \textbf{70.95} & \textbf{77.70} \\
        \bottomrule
    \end{tabular}
    \vspace{5pt}
    \caption{BLOOM accuracy on PIQA.}
    \label{tab:bloom-arc-piqa}
\end{table}

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|}
        \toprule
        OPT & Bits & 125M & 350M & 1.3B & 2.7B & 6.7B & 13B & 30B & 66B & 175B \\
        \midrule
        full & 16 & 39.69 & 40.36 & 50.93 & 54.34 & 60.14 & 61.83 & 65.40 & 67.26 & 71.04 \\
        \midrule
        RTN & 4 & 36.32 & \textbf{38.55} & 49.20 & 52.90 & 57.68 & 61.31 & 61.11 & 40.66 & 63.93 \\
        GPTQ & 4 & \textbf{39.02} & 37.92 & \textbf{59.97} & \textbf{53.11} & \textbf{59.72} & \textbf{61.32} & \textbf{65.11} & \textbf{65.35} & \textbf{68.69} \\
        \midrule
        RTN & 3 & 30.43 & 36.07 & 27.97 & 26.05 & 25.04 & 30.60 & 34.22 & 25.84 & 26.77 \\
        GPTQ & 3 & \textbf{36.15} & \textbf{36.91} & \textbf{46.17} & \textbf{48.19} & \textbf{53.41} & \textbf{56.82} & \textbf{59.72} & \textbf{52.44} & \textbf{65.36} \\
        \bottomrule
    \end{tabular}
    \vspace{5pt}
    \caption{OPT accuracy on ARC-easy.}
    \label{tab:opt-arc-easy}
\end{table}

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|c|c|c|c|c|c|c|}
        \toprule
        BLOOM & Bits & 560M & 1.1B & 1.7B & 3B & 7.1B & 176B \\
        \midrule
        full & 16 & 41.71 & 45.41 & 48.11 & 53.24 & 57.37 & 67.47 \\
        \midrule
        RTN & 4 & 39.40 & 42.51 & \textbf{44.70} & 51.35 & \textbf{56.14} & 66.33 \\
        GPTQ & 4 & \textbf{40.24} & \textbf{44.49} & 44.49 & \textbf{52.82} & \textbf{56.14} & \textbf{67.42} \\
        \midrule
        RTN & 3 & \textbf{45.44} & \textbf{46.87} & 37.58 & 45.08 & 48.61 & 28.87 \\
        GPTQ & 3 & 39.14 & 41.79 & \textbf{42.85} & \textbf{46.63} & \textbf{51.56} & \textbf{62.84} \\
        \bottomrule
    \end{tabular}
    \vspace{5pt}
    \caption{BLOOM accuracy on ARC-easy.}
    \label{tab:bloom-arc-easy}
\end{table}

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|}
        \toprule
        OPT & Bits & 125M & 350M & 1.3B & 2.7B & 6.7B & 13B & 30B & 66B & 175B \\
        \midrule
        full & 16 & 22.87 & 24.06 & 29.44 & 31.31 & 34.56 & 35.75 & 38.14 & 40.02 & 43.94 \\
        \midrule
        RTN & 4 & 22.44 & 23.81 & 24.91 & 29.18 & 32.59 & \textbf{35.24} & 35.41 & 22.87 & 37.71 \\
        GPTQ & 4 & \textbf{22.95} & \textbf{24.83} & \textbf{28.24} & \textbf{30.12} & \textbf{33.70} & 34.90 & \textbf{37.80} & \textbf{39.16} & \textbf{42.75} \\
        \midrule
        RTN & 3 & 21.76 & 22.18 & 23.55 & 25.43 & 25.85 & 23.81 & 19.97 & 25.77 & 23.81 \\
        GPTQ & 3 & \textbf{22.53} & \textbf{25.09} & \textbf{27.65} & \textbf{27.82} & \textbf{31.91} & \textbf{33.02} & \textbf{35.84} & \textbf{31.66} & \textbf{41.04} \\
        \bottomrule
    \end{tabular}
    \vspace{5pt}
    \caption{OPT accuracy on ARC-challenge.}
    \label{tab:opt-arc-challenge}
\end{table}

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|c|c|c|c|c|c|c|}
        \toprule
        BLOOM & Bits & 560M & 1.1B & 1.7B & 3B & 7.1B & 176B \\
        \midrule
        full & 16 & 24.15 & 25.68 & 26.79 & 30.55 & 33.45 & 44.97 \\
        \midrule
        RTN & 4 & \textbf{23.89} & 23.34 & \textbf{26.45} & \textbf{29.52} & 32.17 & 43.17 \\
        GPTQ & 4 & 23.46 & \textbf{25.51} & 25.94 & 28.92 & \textbf{32.25} & \textbf{44.20} \\
        \midrule
        RTN & 3 & 21.67 & 22.86 & 23.29 & 27.13 & \textbf{31.31} & 24.74 \\
        GPTQ & 3 & \textbf{23.21} & \textbf{24.06} & \textbf{24.91} & \textbf{28.58} & 30.97 & \textbf{40.70} \\
        \bottomrule
    \end{tabular}
    \vspace{5pt}
    \caption{BLOOM accuracy on ARC-challenge.}
    \label{tab:bloom-arc-challenge}
\end{table}

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|}
        \toprule
        OPT & Bits & 125M & 350M & 1.3B & 2.7B & 6.7B & 13B & 30B & 66B & 175B \\
        \midrule
        full & 16 & 59.96 & 63.21 & 70.78 & 71.74 & 74.60 & 76.64 & 77.28 & 77.34 & 79.82 \\
        \midrule
        RTN & 4 & \textbf{60.02} & 63.08 & 59.13 & \textbf{70.78} & 73.65 & 74.47 & 75.37 & 51.24 & 78.04 \\
        GPTQ & 4 & 59.58 & \textbf{63.46} & \textbf{69.64} & 70.46 & \textbf{73.90} & \textbf{76.19} & \textbf{77.08} & \textbf{77.15} & \textbf{80.08} \\
        \midrule
        RTN & 3 & 49.65 & 56.78 & 47.61 & 46.98 & 48.12 & 49.20 & 49.84 & 48.19 & 46.47 \\
        GPTQ & 3 & \textbf{57.03} & \textbf{60.15} & \textbf{65.25} & \textbf{68.43} & \textbf{70.97} & \textbf{73.07} & \textbf{75.68} & \textbf{71.23} & \textbf{78.04} \\
        \bottomrule
    \end{tabular}
    \vspace{5pt}
    \caption{OPT accuracy on StoryCloze.}
    \label{tab:opt-storycloze}
\end{table}
        
\begin{table}[h!]
    \centering
    \begin{tabular}{|l|c|c|c|c|c|c|c|}
        \toprule
        BLOOM & Bits & 560M & 1.1B & 1.7B & 3B & 7.1B & 176B \\
        \midrule
        full & 16 & 61.94 & 63.27 & 65.44 & 67.79 & 71.99 & 76.89 \\
        \midrule
        RTN & 4 & 60.15 & 60.66 & 62.95 & 67.09 & 70.72 & 76.00 \\
        GPTQ & 4 & \textbf{61.17} & \textbf{62.32} & \textbf{64.48} & \textbf{67.22} & \textbf{71.36} & \textbf{76.32} \\
        \midrule
        RTN & 3 & 54.87 & 56.08 & 55.79 & 59.83 & 66.20 & 48.50 \\
        GPTQ & 3 & \textbf{57.80} & \textbf{59.77} & \textbf{61.81} & \textbf{63.97} & \textbf{69.26} & \textbf{75.37} \\
        \bottomrule
    \end{tabular}
    \vspace{5pt}
    \caption{BLOOM accuracy on StoryCloze.}
    \label{tab:bloom-storycloze}
\end{table}

\end{document}